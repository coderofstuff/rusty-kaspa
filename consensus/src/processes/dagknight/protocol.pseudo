

Assume arrays of accurate sizes past_blues, past_reds, anticone_blues for each block

Assume an array L of lower bounds of red anticone sizes

Invariant: 
    L[i] ≤ |(G \ U) ⋂ anticone(i)| = |anticone_reds(i)|

Definition:

score_i =  |U ⋂ future(i)|                              - |(G \ U) ⋂ future(i)|
        =  |future_blues(i)|                            - |future_reds(i)|
        =  |U| - past_blues[i] - anticone_blues[i] - 1  - (|(G \ U)| - past_reds[i] - |anticone_reds(i)| - 1)
        =  |U| - past_blues[i] - anticone_blues[i]      - (|(G \ U)| - past_reds[i] - |anticone_reds(i)|)
        ≥  |U| - past_blues[i] - anticone_blues[i]      - (|(G \ U)| - past_reds[i] - L[i])

Denote the score lower bound:

floor_i := |U| - past_blues[i] - anticone_blues[i]      - (|(G \ U)| - past_reds[i] - L[i])

So
    floor_i ≤ score_i

Observe that floor[i] is accessible via arrays

---------------------------------------------------

Let vote_i be the result of the real vote algorithm

Note that vote_i ≤ score_i (because blues can turn negative but not vice versa)


Observation: if floor_i ≥ -d for all i, then we are done

Proof:
    There are no negative blues so vote_i = score_i ≥ floor_i ≥ -d


---------------------------------------------------

Algorithm 1:
    let H denote a heap of floor values  
    let N = 0 // Negative blues counter
    loop:
        let f_i = pop min floor value from H // i is the block index
        if f_i < -d:
            calc score_i accurately and update L[i]
            if f_i increased:
                push updated f to H
            else:
                N = N + 1